{"id":"js/shaders/fragment.glsl","dependencies":[{"name":"C:\\Users\\ASUS\\Desktop\\projects\\THREEJS-Experiments\\New folder\\package.json","includedInParent":true,"mtime":1708161274486}],"generated":{"js":"module.exports = \"#define GLSLIFY 1\\nuniform vec2 u_resolution;\\nuniform vec2 u_mouse;\\nuniform float u_time;\\nvarying vec2 vUv;\\n\\n\\t// Simplex 2D noise\\n  //\\nvec3 permute(vec3 x) {\\n    return mod(((x * 34.0) + 1.0) * x, 289.0);\\n}\\nfloat snoise(vec2 v) {\\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\\n    vec2 i = floor(v + dot(v, C.yy));\\n    vec2 x0 = v - i + dot(i, C.xx);\\n    vec2 i1;\\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\\n    vec4 x12 = x0.xyxy + C.xxzz;\\n    x12.xy -= i1;\\n    i = mod(i, 289.0);\\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\\n    m = m * m;\\n    m = m * m;\\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\\n    vec3 h = abs(x) - 0.5;\\n    vec3 ox = floor(x + 0.5);\\n    vec3 a0 = x - ox;\\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\\n    vec3 g;\\n    g.x = a0.x * x0.x + h.x * x0.y;\\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\\n    return 130.0 * dot(m, g);\\n}\\n  #define OCTAVES 4\\nfloat fbm(in vec2 st) {\\n      // Initial values\\n    float value = 0.0;\\n    float amplitude = .5;\\n    float frequency = 0.;\\n      //\\n      // Loop of octaves\\n    for(int i = 0; i < OCTAVES; i++) {\\n        value += amplitude * snoise(st);\\n        st *= 2.;\\n        amplitude *= .5;\\n    }\\n    return value;\\n}\\n\\nfloat pattern(in vec2 p) {\\n    float t = u_time * 0.04;\\n\\n    vec2 q = vec2(fbm(p + vec2(0.0, 0.0)), fbm(p + vec2(5.2, 1.3)));\\n\\n    vec2 r = vec2(fbm(p + 1.0 * q + vec2(1.7, 9.2) + t), fbm(p + 1.0 * q + vec2(8.3, 2.8) - t));\\n\\n    return fbm(p + r);\\n}\\n\\nvoid main() {\\n    vec2 uv = vUv;\\n\\n    float n = pattern(uv);\\n\\n    vec3 color = vec3(n);\\n\\n    gl_FragColor = vec4(color, 1.0);\\n}\";"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":1,"column":0},"source":"js/shaders/fragment.glsl","original":{"line":1,"column":0},"name":"module"},{"generated":{"line":1,"column":6},"source":"js/shaders/fragment.glsl","original":{"line":1,"column":6}},{"generated":{"line":1,"column":7},"source":"js/shaders/fragment.glsl","original":{"line":1,"column":7},"name":"exports"},{"generated":{"line":1,"column":14},"source":"js/shaders/fragment.glsl","original":{"line":1,"column":14}},{"generated":{"line":1,"column":17},"source":"js/shaders/fragment.glsl","original":{"line":1,"column":15}},{"generated":{"line":1,"column":1862},"source":"js/shaders/fragment.glsl","original":{"line":1,"column":1860}}],"sources":{"js/shaders/fragment.glsl":"module.exports=\"#define GLSLIFY 1\\nuniform vec2 u_resolution;\\nuniform vec2 u_mouse;\\nuniform float u_time;\\nvarying vec2 vUv;\\n\\n\\t// Simplex 2D noise\\n  //\\nvec3 permute(vec3 x) {\\n    return mod(((x * 34.0) + 1.0) * x, 289.0);\\n}\\nfloat snoise(vec2 v) {\\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\\n    vec2 i = floor(v + dot(v, C.yy));\\n    vec2 x0 = v - i + dot(i, C.xx);\\n    vec2 i1;\\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\\n    vec4 x12 = x0.xyxy + C.xxzz;\\n    x12.xy -= i1;\\n    i = mod(i, 289.0);\\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\\n    m = m * m;\\n    m = m * m;\\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\\n    vec3 h = abs(x) - 0.5;\\n    vec3 ox = floor(x + 0.5);\\n    vec3 a0 = x - ox;\\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\\n    vec3 g;\\n    g.x = a0.x * x0.x + h.x * x0.y;\\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\\n    return 130.0 * dot(m, g);\\n}\\n  #define OCTAVES 4\\nfloat fbm(in vec2 st) {\\n      // Initial values\\n    float value = 0.0;\\n    float amplitude = .5;\\n    float frequency = 0.;\\n      //\\n      // Loop of octaves\\n    for(int i = 0; i < OCTAVES; i++) {\\n        value += amplitude * snoise(st);\\n        st *= 2.;\\n        amplitude *= .5;\\n    }\\n    return value;\\n}\\n\\nfloat pattern(in vec2 p) {\\n    float t = u_time * 0.04;\\n\\n    vec2 q = vec2(fbm(p + vec2(0.0, 0.0)), fbm(p + vec2(5.2, 1.3)));\\n\\n    vec2 r = vec2(fbm(p + 1.0 * q + vec2(1.7, 9.2) + t), fbm(p + 1.0 * q + vec2(8.3, 2.8) - t));\\n\\n    return fbm(p + r);\\n}\\n\\nvoid main() {\\n    vec2 uv = vUv;\\n\\n    float n = pattern(uv);\\n\\n    vec3 color = vec3(n);\\n\\n    gl_FragColor = vec4(color, 1.0);\\n}\";"},"lineCount":null}},"error":null,"hash":"fb27f54b1743b437257eea16b42b1dcc","cacheData":{"env":{}}}